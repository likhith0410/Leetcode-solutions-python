LeetCode Problem 909: Snakes and Ladders

Difficulty: Medium

ğŸ§  Problem Statement:
You are given an n x n board for the classic Snakes and Ladders game.
The board is filled with numbers in Boustrophedon order (left-to-right, then right-to-left alternately).
You start at square 1 and want to reach square nÂ².
On each move, you roll a die (1â€“6) and move forward that many steps.
If you land on a square with a snake or ladder (board[r][c] != -1), you must move to its destination.
A snake/ladder is applied at most once per move.
Return the minimum number of moves required to reach square nÂ². If impossible, return -1.

âœ… Example:

Input:
board = [
 [-1,-1,-1,-1,-1,-1],
 [-1,-1,-1,-1,-1,-1],
 [-1,-1,-1,-1,-1,-1],
 [-1,35,-1,-1,13,-1],
 [-1,-1,-1,-1,-1,-1],
 [-1,15,-1,-1,-1,-1]
]
Output:4

âœ… Approach (BFS on Flattened Board):

Observation:
-This is a shortest path problem on a board graph.
-Each position can go to at most 6 next positions (due to die roll).
-BFS ensures the minimum moves are found.
Steps:
-Flatten the 2D board into a 1D array arr where arr[i] tells if a square has a snake/ladder (destination square).
--Start from bottom-left â†’ move row by row alternating direction.
-Perform BFS starting at square 1:
--Track (position, moves) in a queue.
--For each dice roll (1â€“6), calculate next.
--If arr[next] != -1, move to that destination.
--Mark visited squares to avoid revisits.
-If we reach nÂ², return moves. Otherwise return -1.

ğŸ’» Code (Python):
from collections import deque
from typing import List

class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        n = len(board)
        
        # Step 1: Flatten board to 1D
        arr = [-1] * (n*n + 1)
        idx = 1
        left_to_right = True
        
        for r in range(n-1, -1, -1):
            if left_to_right:
                for c in range(n):
                    arr[idx] = board[r][c]
                    idx += 1
            else:
                for c in range(n-1, -1, -1):
                    arr[idx] = board[r][c]
                    idx += 1
            left_to_right = not left_to_right

        # Step 2: BFS
        q = deque([(1, 0)])  # (position, moves)
        visited = set([1])
        
        while q:
            pos, moves = q.popleft()
            
            if pos == n*n:   # Reached the end
                return moves
            
            for dice in range(1, 7):
                nxt = pos + dice
                if nxt > n*n:
                    continue
                if arr[nxt] != -1:   # snake or ladder
                    nxt = arr[nxt]
                if nxt not in visited:
                    visited.add(nxt)
                    q.append((nxt, moves + 1))
        
        return -1

ğŸ” Dry Run:

Input:
board = [
 [-1,-1,-1,-1,-1,-1],
 [-1,-1,-1,-1,-1,-1],
 [-1,-1,-1,-1,-1,-1],
 [-1,35,-1,-1,13,-1],
 [-1,-1,-1,-1,-1,-1],
 [-1,15,-1,-1,-1,-1]
]

Flattened board (arr):

1 â†’ -1, 2 â†’ 15, 3 â†’ -1, 4 â†’ -1, 5 â†’ -1, 6 â†’ -1, ...
8 â†’ 35, 14 â†’ 13, etc.

Start BFS:
Step 1: pos=1 â†’ dice roll to {2,3,4,5,6,7} â†’ 2 leads to ladder â†’ 15
Step 2: pos=15 â€¦ eventually reach 35 â†’ shortcut
Step 3: continue BFS â€¦ reach final square 36.

âœ… Minimum moves = 4

ğŸ“Š Time Complexity:
-Flatten board: O(nÂ²)
-BFS traversal: O(nÂ²) (each square visited once).

ğŸ§  Space Complexity:
-O(nÂ²) for flattened board + visited set + BFS queue.
