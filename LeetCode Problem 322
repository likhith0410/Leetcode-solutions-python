LeetCode Problem 322: Coin Change

Difficulty: Medium

ğŸ§  Problem Statement:
You are given an integer array coins representing coin denominations and an integer amount.
Return the minimum number of coins needed to make amount.
If itâ€™s impossible, return -1.
You have infinite supply of each coin.

ğŸ‘‰ Key Insights:
This is a classic DP (Unbounded Knapsack) problem.
Define dp[i] = minimum coins needed to make amount i.
Base case: dp[0] = 0.
Transition:
dp[i] = min(dp[i], dp[i - coin] + 1)   for each coin <= i

Answer: dp[amount], or -1 if unreachable.

âœ… Approach (Dynamic Programming - Bottom Up):
Initialize DP array with âˆ (meaning impossible initially).
Set dp[0] = 0 â†’ no coins needed for amount 0.
For each amount i from 1 â†’ amount:
-Try every coin:
--If i - coin >= 0, update dp[i] = min(dp[i], dp[i-coin] + 1).
At the end, return dp[amount] (or -1 if still âˆ).

ğŸ“ Code:
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # Initialize DP array with infinity (unreachable)
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0  # Base case: 0 coins to make 0

        for i in range(1, amount + 1):
            for coin in coins:
                if i - coin >= 0:
                    dp[i] = min(dp[i], dp[i - coin] + 1)

        return dp[amount] if dp[amount] != float('inf') else -1


ğŸ” Dry Run:
Input: coins = [1,2,5], amount = 11
dp[0] = 0
Build up:
dp[1] = 1 (1 coin of 1)
dp[2] = 1 (1 coin of 2)
dp[3] = 2 (2 + 1)
dp[5] = 1 (one 5)
dp[11] = 3 (5 + 5 + 1)

âœ… Final Answer: 3

ğŸ“Š Time Complexity:
-O(amount Ã— number_of_coins)

ğŸ§  Space Complexity:
-O(amount) for the DP array
