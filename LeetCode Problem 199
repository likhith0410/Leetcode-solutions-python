LeetCode Problem 199: Binary Tree Right Side View

Difficulty: Medium

🧠 Problem Statement:
Given the root of a binary tree, imagine yourself standing on the right side of it.
Return the values of the nodes you can see ordered from top to bottom.

✅ Example:
Input:root = [1,2,3,null,5,null,4]
Output:[1,3,4]

Explanation:
From the right side, you can see nodes 1 → 3 → 4.

✅ Approach:
We solve this using DFS (Depth-First Search) with right-first traversal:
-Use recursion with a depth tracker.
-At each depth, if it’s the first time we visit that level, add the node’s value to the result.
--This ensures we always take the rightmost node at each level.
-Traverse right child first, then left child.
--This guarantees right-side nodes are prioritized.

💻 Code (Python):

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        
        def dfs(node, depth):
            if not node:
                return
            # First node we visit at this depth → rightmost
            if depth == len(res):
                res.append(node.val)
            
            # Visit right first, then left
            dfs(node.right, depth + 1)
            dfs(node.left, depth + 1)
        
        dfs(root, 0)
        return res


🔁 Dry Run:
Input: root = [1,2,3,null,5,null,4]

Tree:

        1
       / \
      2   3
       \    \
        5    4


Steps:
Depth 0: Add 1 → res = [1]
Depth 1: Right child 3 seen first → res = [1,3]
Depth 2: Right child 4 seen first → res = [1,3,4]

✅ Final Output: [1,3,4]

📊 Time Complexity:
-O(n): Each node is visited once (n = number of nodes).

🧠 Space Complexity:
-O(h): Recursion stack, where h = tree height.
-Worst case (skewed tree) → O(n).
-Best case (balanced tree) → O(log n).
