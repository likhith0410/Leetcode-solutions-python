LeetCode Problem 102: Binary Tree Level Order Traversal

Difficulty: Medium

üß† Problem Statement:

Given the root of a binary tree, return the level order traversal of its nodes' values.
(i.e., from left to right, level by level).

‚úÖ Example:
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]

‚úÖ Approach:
We can solve this using Breadth-First Search (BFS) with a queue:
Observation:
-In level order traversal, we process nodes level by level.
-BFS naturally handles this using a queue.
Steps:
-If the tree is empty ‚Üí return an empty list.
-Initialize a queue with the root node.
While the queue is not empty:
-Determine the number of nodes in the current level (level_size).
-Process all nodes in this level, adding their values to a level_nodes list.
-Push their children (if any) into the queue for the next level.
Append each level‚Äôs list of values into the final result.
Return the result list.
This ensures O(n) traversal where n is the number of nodes.

üíª Code (Python):
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        queue = deque([root])   # Start BFS with root

        while queue:
            level_size = len(queue)   # number of nodes in current level
            level_nodes = []          # stores values of this level

            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node.val)

                # push children into queue
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            # add this level‚Äôs result
            result.append(level_nodes)

        return result

üîÅ Dry Run:

Input: root = [3,9,20,null,null,15,7]
Start with root 3. Queue = [3]
Level 1 ‚Üí [3]. Queue = [9,20]
Level 2 ‚Üí [9,20]. Queue = [15,7]
Level 3 ‚Üí [15,7]. Queue = []
Final Output: [[3],[9,20],[15,7]]

üìä Time Complexity:
O(n): Each node is visited exactly once.

üß† Space Complexity:
O(n): Queue storage for BFS (in the worst case, one level may hold n/2 nodes).
