LeetCode Problem 148: Sort List

Difficulty: Medium

🧠 Problem Statement:
Given the head of a linked list, return the list after sorting it in ascending order.

Example:
Input:head = [4,2,1,3]
Output:[1,2,3,4]

✅ Approach: Merge Sort on Linked List

👉 Why Merge Sort?
Array sorting (like quicksort) needs random access, which linked lists don’t support efficiently.
Merge sort works well on linked lists because splitting and merging can be done in O(1) extra space.
Steps:
-Base case:
--If list is empty or has one node → already sorted.
-Split the list:
--Use slow & fast pointers to find the middle node.
--Break list into two halves.
-Recursively sort:
--Sort left and right halves.
-Merge sorted halves:
--Use helper merge function to merge two sorted lists.

📝 Code
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Base case: empty or single node
        if not head or not head.next:
            return head

        # 1. Split list into two halves
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        mid = slow.next
        slow.next = None   # cut the list

        # 2. Recursively sort both halves
        left = self.sortList(head)
        right = self.sortList(mid)

        # 3. Merge sorted halves
        return self.merge(left, right)

    def merge(self, l1, l2):
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next


🔁 Dry Run:
Input: head = [4,2,1,3]
Split into [4,2] and [1,3].
Sort [4,2] → becomes [2,4].
Sort [1,3] → becomes [1,3].
Merge [2,4] and [1,3]:
Compare 2 vs 1 → take 1.
Compare 2 vs 3 → take 2.
Compare 4 vs 3 → take 3.
Append remaining 4.

Final: [1,2,3,4] ✅

📊 Time Complexity:
-Splitting = O(log n) levels.
-Merging = O(n) work per level.
-Total = O(n log n).

🧠 Space Complexity:
-Merge uses no extra array (just pointers).
-Recursion stack depth = O(log n).
