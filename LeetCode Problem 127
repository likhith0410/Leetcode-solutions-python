LeetCode Problem 127: Word Ladder

Difficulty: Hard

üß† Problem Statement:
We are given two words:
beginWord ‚Üí starting word.
endWord ‚Üí target word.
And a dictionary wordList.
A valid transformation sequence must:
Change only one letter at a time.
Every intermediate word must exist in wordList.
End at endWord.

Return the length of the shortest transformation sequence (number of words).
If no such sequence exists, return 0.

‚úÖ Example:

Input:
beginWord = "hit"
endWord   = "cog"
wordList  = ["hot","dot","dog","lot","log","cog"]

Output:5

Explanation:
One shortest sequence is:
"hit" ‚Üí "hot" ‚Üí "dot" ‚Üí "dog" ‚Üí "cog" ‚Üí length = 5

‚úÖ Approach (BFS ‚Äì Shortest Path in Word Graph):
Observation:
-Each word is a node.
-There‚Äôs an edge between two words if they differ by exactly 1 character.
-We want the shortest path from beginWord ‚Üí endWord.
-Use BFS to guarantee shortest transformation.
Steps:
-Store wordList in a set for O(1) lookups.
-If endWord not in the set ‚Üí no transformation possible ‚Üí return 0.
-Initialize BFS queue: (beginWord, 1) where 1 = step count.
-For each word, generate all possible 1-letter mutations.
-If mutation exists in wordList and not visited ‚Üí push into queue.
-If endWord is reached ‚Üí return step count.
-If BFS ends without reaching endWord ‚Üí return 0.

üíª Code (Python):
from collections import deque
from typing import List

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        word_set = set(wordList)
        if endWord not in word_set:
            return 0  # No valid path

        queue = deque([(beginWord, 1)])  # (word, steps)
        visited = set([beginWord])

        while queue:
            word, steps = queue.popleft()

            if word == endWord:
                return steps

            # Try changing each letter
            for i in range(len(word)):
                for c in "abcdefghijklmnopqrstuvwxyz":
                    if c != word[i]:
                        new_word = word[:i] + c + word[i+1:]
                        if new_word in word_set and new_word not in visited:
                            visited.add(new_word)
                            queue.append((new_word, steps + 1))

        return 0

üîÅ Dry Run:

Input:

beginWord = "hit"
endWord   = "cog"
wordList  = ["hot","dot","dog","lot","log","cog"]

Start = "hit", steps = 1.
Mutations: "hot" (valid, push to queue).

"hot", steps = 2.
Mutations: "dot", "lot" (valid).

"dot", steps = 3.
Mutations: "dog" (valid).

"dog", steps = 4.
Mutations: "cog" (valid, target found).

‚úÖ Output = 5

üìä Time Complexity:
-Each word has length L.
-For each word, we try L √ó 25 possible mutations.
-With N = len(wordList), worst-case BFS explores all words.
-O(N √ó L √ó 26)

üß† Space Complexity:
-O(N) for visited set and queue.
