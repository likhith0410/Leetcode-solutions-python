LeetCode Problem 149: Max Points on a Line

Difficulty: Hard

ðŸ§  Problem Statement:
You are given an array of points, where points[i] = [xi, yi].
Return the maximum number of points that lie on the same straight line.
ðŸ‘‰ Key Insights:
Any line between two points can be represented by its slope 
(ð‘‘ð‘¦/ð‘‘ð‘¥)
(dy/dx).
If multiple points share the same slope w.r.t. a given base point, they are collinear.
Issues to handle:
Duplicate points â†’ count them separately.
Vertical lines (dx = 0) â†’ slope is undefined, handle specially.
Fraction precision â†’ reduce slope to lowest terms using gcd(dx, dy).

âœ… Approach:
Iterate over each point i as the anchor point.
For every other point j, calculate slope (dy, dx).
Normalize slope:
-Divide by gcd(dx, dy) to avoid floating-point errors.
-Make slope representation unique (e.g., ensure dx â‰¥ 0).
Count slopes in a hashmap (slopes).
Track duplicates (points exactly same as anchor).
For each anchor, max points on a line =
cur_max + duplicates + 1 (including anchor itself).

Return the global maximum.

ðŸ“ Code:
from collections import defaultdict
from math import gcd
from typing import List

class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 2:
            return n

        max_points = 1

        for i in range(n):
            slopes = defaultdict(int)
            duplicates = 0
            cur_max = 0

            xi, yi = points[i]
            for j in range(i + 1, n):
                xj, yj = points[j]
                dx = xj - xi
                dy = yj - yi

                if dx == 0 and dy == 0:  # duplicate point
                    duplicates += 1
                    continue

                g = gcd(dx, dy)
                dx //= g
                dy //= g

                # normalize slope representation
                if dx == 0:
                    dy = 1      # vertical line
                elif dy == 0:
                    dx = 1      # horizontal line
                elif dx < 0:
                    dx, dy = -dx, -dy

                slopes[(dy, dx)] += 1
                cur_max = max(cur_max, slopes[(dy, dx)])

            max_points = max(max_points, cur_max + duplicates + 1)

        return max_points


ðŸ” Dry Run:
Input: points = [[1,1],[2,2],[3,3]]
Anchor = [1,1]:
Compare with [2,2] â†’ slope = (1,1)
Compare with [3,3] â†’ slope = (1,1)
â†’ Both share same slope â†’ collinear â†’ cur_max = 2.

Max points = 2 + 0 + 1 = 3.
âœ… Final Output: 3

ðŸ“Š Time Complexity:
-O(nÂ²): For each point, compare with every other point.

ðŸ§  Space Complexity:
-O(n): Hashmap for slopes per anchor point.
