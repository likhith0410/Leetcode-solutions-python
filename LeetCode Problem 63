LeetCode Problem 63: Unique Paths II

Difficulty: Medium

üß† Problem Statement:
You are given an m x n grid with obstacles.
0 ‚Üí empty space
1 ‚Üí obstacle
A robot starts at the top-left corner (0,0) and wants to reach the bottom-right corner (m-1,n-1).
The robot can only move right or down.

üëâ Return the number of unique paths the robot can take to reach the destination without passing through obstacles.

Example:
Input:

obstacleGrid = [[0,0,0],
                [0,1,0],
                [0,0,0]]


Output: 2
Explanation:
There are 2 valid paths:
Right ‚Üí Right ‚Üí Down ‚Üí Down
Down ‚Üí Down ‚Üí Right ‚Üí Right

‚úÖ Approach (Dynamic Programming):

Use a DP table (dp[i][j]) where each cell stores the number of unique paths to reach that cell.
Base case:
-If the starting cell (0,0) has an obstacle ‚Üí 0 ways.
Transition:
-If obstacleGrid[i][j] == 1 ‚Üí no path (dp[i][j] = 0).
-Otherwise:
--dp[i][j] = dp[i-1][j] + dp[i][j-1]
--(sum of ways from top and left).
Fill first row and first column carefully ‚Üí only 1 way unless blocked by an obstacle.
Final answer: dp[m-1][n-1].

üìù Code:

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[0] * n for _ in range(m)]
        
        # Start cell
        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0
        
        # Fill first column
        for i in range(1, m):
            if obstacleGrid[i][0] == 0:
                dp[i][0] = dp[i-1][0]
        
        # Fill first row
        for j in range(1, n):
            if obstacleGrid[0][j] == 0:
                dp[0][j] = dp[0][j-1]
        
        # Fill rest of the grid
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        
        return dp[m-1][n-1]


üîÅ Dry Run:
Input:

obstacleGrid = [[0,0,0],
                [0,1,0],
                [0,0,0]]


Start: dp[0][0] = 1
First row: [1,1,1]
First col: [1,1,1]
Middle cell (1,1) is obstacle ‚Üí dp[1][1] = 0

Fill rest:

dp = [[1,1,1],
      [1,0,1],
      [1,1,2]]

‚úÖ Final Answer = dp[2][2] = 2

üìä Time Complexity:
-O(m * n) ‚Üí fill each cell once.

üß† Space Complexity:
-O(m * n) for DP table.
-Can be optimized to O(n) (1D DP).
