LeetCode Problem 137: Single Number II

Difficulty: Medium

ğŸ§  Problem Statement:
You are given an integer array nums where:
Every element appears three times, except one element that appears exactly once.
Return the single element.
Constraints:
Must run in O(n) time.
Must use O(1) extra space.
Example 1
Input:nums = [2,2,3,2]
Output:3

Explanation:
2 appears 3 times â†’ cancel it.
3 appears once â†’ answer = 3.

âœ… Approach (Bit Manipulation with Counters):
We canâ€™t use XOR alone here (like in problem 136), because numbers appear 3 times instead of 2.
Idea:
-Keep track of bits that appeared once (ones).
-Keep track of bits that appeared twice (twos).
-When a number appears the third time, both ones and twos reset (cancel out).
Update rules for each num:
-ones = (ones ^ num) & ~twos â†’ track bits seen once, remove if seen in twos.
-twos = (twos ^ num) & ~ones â†’ track bits seen twice, remove if seen in ones.
At the end, ones = number that appeared only once.

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ones, twos = 0, 0
        for num in nums:
            ones = (ones ^ num) & ~twos
            twos = (twos ^ num) & ~ones
        return ones


ğŸ” Dry Run:
Input: nums = [2,2,3,2]
Start: ones = 0, twos = 0
Step 1 â†’ num = 2
ones = (0 ^ 2) & ~0 = 2
twos = (0 ^ 2) & ~2 = 0
Step 2 â†’ num = 2
ones = (2 ^ 2) & ~0 = 0
twos = (0 ^ 2) & ~0 = 2
Step 3 â†’ num = 3
ones = (0 ^ 3) & ~2 = 1
twos = (2 ^ 3) & ~1 = 2
Step 4 â†’ num = 2
ones = (1 ^ 2) & ~2 = 3
twos = (2 ^ 2) & ~3 = 0

âœ… Result: ones = 3 â†’ thatâ€™s the unique number.

ğŸ“Š Time Complexity:
-O(n) â†’ one pass through array.

ğŸ§  Space Complexity:
-O(1) â†’ only two variables (ones, twos).

âš¡ Key Insight:
Each bitâ€™s count cycles like this:
count = 0 â†’ 1 â†’ 2 â†’ (reset back to 0)
ones stores bits in count = 1 state.
twos stores bits in count = 2 state.
After 3rd occurrence, bits reset to 0.
