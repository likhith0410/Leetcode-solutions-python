LeetCode Problem 9: Palindrome Number

Difficulty: Easy

🧠 Problem Statement:
Given an integer x, return True if x is a palindrome, otherwise False.
A palindrome is a number that reads the same backward as forward.

Example 1
Input:x = 121
Check:
Forward → 121
Backward → 121
Output:True

✅ Approach (Reverse Half of the Number):
Why reverse only half?
-Reversing the whole number may cause overflow for very large numbers.
-If you reverse only half, you avoid that problem and save extra steps.
Steps:
Handle edge cases:
-Negative numbers → always False.
-Numbers ending in 0 (like 10, 100) can’t be palindromes unless the number is 0.
Build a reversed half rev.
-Take digits from the end of x one by one.
-Stop when rev >= x.
Compare:
-If x == rev (even length case).
-Or x == rev // 10 (odd length case, middle digit ignored).

Code:2
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        return str(x) == str(x)[::-1]        

Code 2:
class Solution:
    def isPalindrome(self, x: int) -> bool:
        # Step 1: Handle edge cases
        if x < 0 or (x % 10 == 0 and x != 0):
            return False

        rev = 0
        # Step 2: Reverse half of the number
        while x > rev:
            rev = rev * 10 + x % 10
            x //= 10

        # Step 3: Compare halves
        return x == rev or x == rev // 10


🔁 Dry Run:
Input: x = 1221
Start: x = 1221, rev = 0
Step 1: rev = 1, x = 122
Step 2: rev = 12, x = 12 → stop (x == rev)
✅ Palindrome → Return True.

📊 Time Complexity:
-O(log₁₀(n)) → we only process half of the digits.

🧠 Space Complexity:
-O(1).

⚡ Key Insight:
Instead of reversing the full number, we just reverse half and compare — efficient and safe against overflow.
