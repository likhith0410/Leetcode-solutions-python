LeetCode Problem 139: Word Break

Difficulty: Medium

ğŸ§  Problem Statement:
Given a string s and a dictionary wordDict, return True if s can be segmented into one or more words from wordDict.
Words may be reused multiple times.
ğŸ‘‰ Key Insights:
We need to check if s[0..i] can be broken into valid words.
Use Dynamic Programming (DP):
dp[i] = True if s[:i] can be segmented.
Transition: dp[i] = True if there exists some j < i where:
dp[j] == True
and s[j:i] âˆˆ wordDict.
Optimization: Only check substring lengths up to the longest word in wordDict.

âœ… Approach:

Initialize dp = [False] * (n+1) where n = len(s).
-dp[0] = True (empty string is valid).
Loop i = 1..n:
-For each i, check backwards j = i-1..max(i - max_word_length, 0).
-If dp[j] is True and s[j:i] in wordDict, mark dp[i] = True.
-Break early when a valid split is found.
Return dp[n] â†’ answer for the whole string.

ğŸ“ Code:
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True
        max_len = max(map(len, wordDict))  # longest word in dict

        for i in range(1, n + 1):
            for j in range(i - 1, max(i - max_len - 1, -1), -1):
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break

        return dp[n]


ğŸ” Dry Run:
Input: s = "leetcode", wordDict = ["leet", "code"]
dp[0] = True
i=4 â†’ substring "leet" found in dict, dp[4]=True
i=8 â†’ dp[4] is True and substring "code" found â†’ dp[8]=True
dp[8] = True â†’ âœ… return True

ğŸ“Š Time Complexity:
-Worst case: O(n * max_word_length).
-Checking substring membership can be O(1) if wordDict is a set.

ğŸ§  Space Complexity:
-O(n): DP array of size n+1.
