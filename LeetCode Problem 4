LeetCode Problem 4: Median of Two Sorted Arrays

Difficulty: Hard

ğŸ§  Problem Statement:
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
ğŸ‘‰ The solution must run in O(log (m+n)) time complexity.

Example:
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: The merged array is [1,2,3], and the median is 2.

âœ… Approach:
We use binary search on the smaller array to partition the two arrays correctly:
Ensure nums1 is the smaller array (to reduce binary search range).
Total elements = m + n.
-Left half size = (total + 1) // 2.
Binary search on nums1:
-i = partition index for nums1.
-j = partition index for nums2 â†’ half - i.
Get boundary values:
-left1 = nums1[i-1] if i > 0 else -âˆ
-right1 = nums1[i] if i < m else +âˆ
-left2 = nums2[j-1] if j > 0 else -âˆ
-right2 = nums2[j] if j < n else +âˆ
Check partition validity:
-If left1 <= right2 and left2 <= right1, partition is correct.
--If total is odd â†’ median = max(left1, left2).
--If total is even â†’ median = (max(left1, left2) + min(right1, right2)) / 2.
-If left1 > right2, move right = i - 1.
-Else move left = i + 1.

class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        # Ensure nums1 is smaller
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1

        m, n = len(nums1), len(nums2)
        total = m + n
        half = (total + 1) // 2

        left, right = 0, m
        while left <= right:
            i = (left + right) // 2  # partition for nums1
            j = half - i             # partition for nums2

            left1 = nums1[i-1] if i > 0 else float("-inf")
            right1 = nums1[i] if i < m else float("inf")
            left2 = nums2[j-1] if j > 0 else float("-inf")
            right2 = nums2[j] if j < n else float("inf")

            # valid partition
            if left1 <= right2 and left2 <= right1:
                if total % 2 == 1:
                    return max(left1, left2)
                else:
                    return (max(left1, left2) + min(right1, right2)) / 2.0
            elif left1 > right2:
                right = i - 1
            else:
                left = i + 1


ğŸ” Dry Run:
Input: nums1 = [1,3], nums2 = [2]
m = 2, n = 1, total = 3, half = 2
Binary search on nums1:
i = 1, j = 1
left1 = 1, right1 = 3
left2 = 2, right2 = inf
Check: 1 <= inf âœ… and 2 <= 3 âœ… â†’ valid partition.
Total is odd â†’ median = max(1,2) = 2.
âœ… Final Output: 2.0

ğŸ“Š Time Complexity:
-O(log(min(m, n))) â†’ Binary search on smaller array.

ğŸ§  Space Complexity:
-O(1) â†’ Only a few variables used.
