LeetCode Problem 130: Surrounded Regions

Difficulty: Medium

üß† Problem Statement:
You are given an m x n matrix board containing letters 'X' and 'O'.
A region is formed by connecting adjacent 'O' cells horizontally or vertically.
A region is surrounded if it is completely enclosed by 'X' cells, and none of its 'O' cells touch the border of the board.

To capture a surrounded region, replace all 'O's with 'X's in-place within the original board.

‚úÖ Example:
Input:board = 
[
 ["X","X","X","X"],
 ["X","O","O","X"],
 ["X","X","O","X"],
 ["X","O","X","X"]
]

Output:
[
 ["X","X","X","X"],
 ["X","X","X","X"],
 ["X","X","X","X"],
 ["X","O","X","X"]
]

‚úÖ Approach:

We use DFS (Depth-First Search) to mark 'O's that cannot be captured.

Key Insight:
-Any 'O' connected to the border cannot be captured.
-We first mark those 'O's as "E" (escaped).
-Then, we flip all other 'O's to 'X'.
-Finally, we turn "E" back into 'O'.
Steps:
-Traverse border cells. For each 'O', perform DFS and mark connected 'O's as "E".
Traverse the entire board:
-Convert remaining 'O' ‚Üí 'X'.
-Convert "E" ‚Üí 'O'.
The board is modified in-place.

üíª Code (Python):
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board: return
        rows, cols = len(board), len(board[0])

        def dfs(r, c):
            if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != "O":
                return
            board[r][c] = "E"  # mark as escaped
            dfs(r+1, c)
            dfs(r-1, c)
            dfs(r, c+1)
            dfs(r, c-1)

        # Step 1: Mark border-connected O's as escaped
        for r in range(rows):
            for c in [0, cols-1]:
                if board[r][c] == "O":
                    dfs(r, c)
        for c in range(cols):
            for r in [0, rows-1]:
                if board[r][c] == "O":
                    dfs(r, c)

        # Step 2: Flip surrounded O ‚Üí X, escaped E ‚Üí O
        for r in range(rows):
            for c in range(cols):
                if board[r][c] == "O":
                    board[r][c] = "X"
                elif board[r][c] == "E":
                    board[r][c] = "O"

üîÅ Dry Run:

Input:

[
 ["X","X","X","X"],
 ["X","O","O","X"],
 ["X","X","O","X"],
 ["X","O","X","X"]
]

Border DFS marks last-row (3,1) as "E".
Traverse all cells:
Convert "O" ‚Üí "X".
Convert "E" ‚Üí "O".

Final Output:
[
 ["X","X","X","X"],
 ["X","X","X","X"],
 ["X","X","X","X"],
 ["X","O","X","X"]
]

üìä Time Complexity:
-O(m √ó n): Each cell visited at most once.

üß† Space Complexity:
-O(m √ó n): Worst-case recursion stack (all cells are 'O').
