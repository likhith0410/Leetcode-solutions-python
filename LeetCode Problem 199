LeetCode Problem 199: Binary Tree Right Side View

Difficulty: Medium

ğŸ§  Problem Statement:
Given the root of a binary tree, imagine yourself standing on the right side of it.
Return the values of the nodes you can see ordered from top to bottom.

âœ… Example:
Input:root = [1,2,3,null,5,null,4]
Output:[1,3,4]

Explanation:
From the right side, you can see nodes 1 â†’ 3 â†’ 4.

âœ… Approach:
We solve this using DFS (Depth-First Search) with right-first traversal:
-Use recursion with a depth tracker.
-At each depth, if itâ€™s the first time we visit that level, add the nodeâ€™s value to the result.
--This ensures we always take the rightmost node at each level.
-Traverse right child first, then left child.
--This guarantees right-side nodes are prioritized.

ğŸ’» Code (Python):

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        
        def dfs(node, depth):
            if not node:
                return
            # First node we visit at this depth â†’ rightmost
            if depth == len(res):
                res.append(node.val)
            
            # Visit right first, then left
            dfs(node.right, depth + 1)
            dfs(node.left, depth + 1)
        
        dfs(root, 0)
        return res


ğŸ” Dry Run:
Input: root = [1,2,3,null,5,null,4]

Tree:

        1
       / \
      2   3
       \    \
        5    4


Steps:
Depth 0: Add 1 â†’ res = [1]
Depth 1: Right child 3 seen first â†’ res = [1,3]
Depth 2: Right child 4 seen first â†’ res = [1,3,4]

âœ… Final Output: [1,3,4]

ğŸ“Š Time Complexity:
-O(n): Each node is visited once (n = number of nodes).

ğŸ§  Space Complexity:
-O(h): Recursion stack, where h = tree height.
-Worst case (skewed tree) â†’ O(n).
-Best case (balanced tree) â†’ O(log n).
