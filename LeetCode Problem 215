LeetCode Problem 215: Kth Largest Element in an Array

Difficulty: Medium

ğŸ§  Problem Statement:
Given an integer array nums and an integer k, return the kth largest element in the array.

ğŸ‘‰ Note: This is the kth largest in sorted order, not necessarily the kth distinct element.
ğŸ‘‰ Try solving it without sorting the entire array.

Example:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Explanation: The sorted array is [1,2,3,4,5,6], and the 2nd largest is 5.

âœ… Approach 1: Min-Heap (Heapq)
-Keep a min-heap of size k.
-Push elements into heap â†’ if size > k, pop smallest.
-After processing all numbers, the root of the heap is the kth largest.


class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        min_heap = []
        for num in nums:
            heapq.heappush(min_heap, num)
            if len(min_heap) > k:
                heapq.heappop(min_heap)
        return min_heap[0]


ğŸ” Dry Run (Heap):
Input: nums = [3,2,1,5,6,4], k = 2
Insert: [3] â†’ [2,3] â†’ pop â†’ [3]
Insert 1 â†’ [1,3] â†’ pop â†’ [3]
Insert 5 â†’ [3,5] (ok)
Insert 6 â†’ [5,6] (after popping smaller)
Insert 4 â†’ [4,6] â†’ pop â†’ [5,6]
âœ… Heap root = 5 (2nd largest).

ğŸ“Š Time Complexity (Heap):
-Insertion/deletion = O(log k) per element.
-Total = O(n log k).

ğŸ§  Space Complexity:
-O(k) for the heap.

âœ… Approach 2: Quickselect (Hoare Partition)
Convert problem: kth largest â†’ (n-k)th smallest.
Use quickselect with random pivot:
-Partition array into < pivot and > pivot.
-If (n-k) lies in left side, recurse left.
-If (n-k) lies in right side, recurse right.
-Otherwise, pivot position is the answer.


class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        k = len(nums) - k  # convert to kth smallest index

        def quickselect(l, r):
            pivot = nums[random.randint(l, r)]
            left, right = l, r

            while left <= right:
                while nums[left] < pivot:
                    left += 1
                while nums[right] > pivot:
                    right -= 1
                if left <= right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left, right = left + 1, right - 1

            if k <= right:
                return quickselect(l, right)
            elif k >= left:
                return quickselect(left, r)
            else:
                return nums[k]

        return quickselect(0, len(nums)-1)


ğŸ” Dry Run (Quickselect):
Input: nums = [3,2,1,5,6,4], k = 2
Target index = 6 - 2 = 4 (4th smallest).
Suppose pivot = 3 â†’ partition â†’ [2,1,3,5,6,4].
Index 4 lies in right side â†’ recurse on [5,6,4].
Pivot = 6 â†’ partition â†’ [5,4,6].
Index 4 now points to 5.
âœ… Result = 5.

ğŸ“Š Time Complexity (Quickselect):
-Average: O(n) (good pivot choices).
-Worst: O(nÂ²) (bad pivots every time).

ğŸ§  Space Complexity:
-O(1) (in-place partition).

âœ¨ Comparison of Approaches:
Heap (O(n log k)) â†’ safer, predictable, best when k is small.
Quickselect (O(n) avg) â†’ faster in practice, but worst-case slower.
