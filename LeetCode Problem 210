LeetCode Problem 210: Course Schedule II

Difficulty: Medium

🧠 Problem Statement:
You are given numCourses courses labeled from 0 to numCourses - 1 and a list of prerequisites, where prerequisites[i] = [a, b] means:
➡ To take course a, you must first complete course b.
Return the order of courses you should take to finish all courses.
If multiple valid orders exist → return any.
If it is impossible to complete all courses (due to cycles), return an empty list.

✅ Example:
Input:numCourses = 2, prerequisites = [[1,0]]
Output:[0,1]

Explanation:
To take course 1, you must first finish 0.
So the valid order is [0,1].

✅ Approach (Topological Sort using BFS - Kahn’s Algorithm):
Observation:
-This is a Directed Graph problem.
-Each course is a node, and prerequisites form directed edges.
-We need to find a topological ordering.
-If a cycle exists → no valid order.
Steps:
-Build a graph (adjacency list) and an indegree array (tracks prerequisites count for each course).
-Initialize a queue with all courses having indegree 0 (no prerequisites).
-Perform BFS:
--Pop a course from the queue → add it to order.
--Reduce indegree of its neighbors (dependent courses).
--If a neighbor’s indegree becomes 0, push it into the queue.
-If all courses are processed → return order.
Otherwise (cycle detected) → return [].

💻 Code (Python):
from collections import deque
from typing import List

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # Step 1: Build graph + indegree count
        graph = {i: [] for i in range(numCourses)}
        indegree = [0] * numCourses

        for a, b in prerequisites:
            graph[b].append(a)   # b -> a (to take a, must do b first)
            indegree[a] += 1

        # Step 2: Queue with nodes having indegree 0 (no prerequisites)
        queue = deque([i for i in range(numCourses) if indegree[i] == 0])
        order = []

        # Step 3: Process queue
        while queue:
            course = queue.popleft()
            order.append(course)

            for neigh in graph[course]:
                indegree[neigh] -= 1
                if indegree[neigh] == 0:
                    queue.append(neigh)

        # Step 4: Check if all courses are processed
        return order if len(order) == numCourses else []

🔁 Dry Run:

Input:numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]

Graph:
0 → [1,2]
1 → [3]
2 → [3]
3 → []

Indegree = [0,1,1,2]
Start with queue = [0]

Process:
Pop 0, order = [0] → update indegree → [0,0,0,2], push 1,2.
Pop 1, order = [0,1] → indegree → [0,0,0,1].
Pop 2, order = [0,1,2] → indegree → [0,0,0,0], push 3.
Pop 3, order = [0,1,2,3].
✅ Final Output: [0,1,2,3]

📊 Time Complexity:
O(V + E) → V = courses, E = prerequisites.
Building graph + BFS traversal.

🧠 Space Complexity:
O(V + E) → Graph + indegree array + queue.
