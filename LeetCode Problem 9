LeetCode Problem 9: Palindrome Number

Difficulty: Easy

ğŸ§  Problem Statement:
Given an integer x, return True if x is a palindrome, otherwise False.
A palindrome is a number that reads the same backward as forward.

Example 1
Input:x = 121
Check:
Forward â†’ 121
Backward â†’ 121
Output:True

âœ… Approach (Reverse Half of the Number):
Why reverse only half?
-Reversing the whole number may cause overflow for very large numbers.
-If you reverse only half, you avoid that problem and save extra steps.
Steps:
Handle edge cases:
-Negative numbers â†’ always False.
-Numbers ending in 0 (like 10, 100) canâ€™t be palindromes unless the number is 0.
Build a reversed half rev.
-Take digits from the end of x one by one.
-Stop when rev >= x.
Compare:
-If x == rev (even length case).
-Or x == rev // 10 (odd length case, middle digit ignored).

Code:2
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        return str(x) == str(x)[::-1]        

Code 2:
class Solution:
    def isPalindrome(self, x: int) -> bool:
        # Step 1: Handle edge cases
        if x < 0 or (x % 10 == 0 and x != 0):
            return False

        rev = 0
        # Step 2: Reverse half of the number
        while x > rev:
            rev = rev * 10 + x % 10
            x //= 10

        # Step 3: Compare halves
        return x == rev or x == rev // 10


ğŸ” Dry Run:
Input: x = 1221
Start: x = 1221, rev = 0
Step 1: rev = 1, x = 122
Step 2: rev = 12, x = 12 â†’ stop (x == rev)
âœ… Palindrome â†’ Return True.

ğŸ“Š Time Complexity:
-O(logâ‚â‚€(n)) â†’ we only process half of the digits.

ğŸ§  Space Complexity:
-O(1).

âš¡ Key Insight:
Instead of reversing the full number, we just reverse half and compare â€” efficient and safe against overflow.
