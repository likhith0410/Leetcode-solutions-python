LeetCode Problem 136: Single Number

Difficulty: Easy

ğŸ§  Problem Statement:
You are given a non-empty array of integers nums, where:
Every element appears exactly twice, except for one element that appears only once.
Find that single unique element.
Constraints:
Must run in O(n) time.
Must use O(1) extra space.

Example 1:
Input:nums = [2,2,1]
Output:1

Explanation:
2 appears twice.
1 appears once â†’ so answer = 1.

âœ… Approach (Bit Manipulation â€” XOR):
Properties of XOR (^):
-a ^ a = 0 (same numbers cancel out)
-a ^ 0 = a
-XOR is commutative and associative (order doesnâ€™t matter).
So, if we XOR all numbers:
-Pairs cancel each other.
-Only the single number remains.

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = 0
        for num in nums:
            res ^= num   # cancel duplicates
        return res


ğŸ” Dry Run:
Input: nums = [2,2,1]
Start: res = 0
Step 1: res = 0 ^ 2 = 2
Step 2: res = 2 ^ 2 = 0
Step 3: res = 0 ^ 1 = 1

âœ… Final Answer = 1

ğŸ“Š Time Complexity:
-O(n) â†’ we go through the array once.

ğŸ§  Space Complexity:
-O(1) â†’ only one variable used.
