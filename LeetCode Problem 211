LeetCode Problem 211: Design Add and Search Words Data Structure

Difficulty: Medium

ğŸ§  Problem Statement:
You need to design a data structure to store words and allow searches with support for a special character:
WordDictionary() â†’ Initializes the object.
addWord(word) â†’ Adds the word to the data structure.
search(word) â†’ Returns true if the word matches any previously added word.
word may contain the wildcard character "." which can match any single letter.

ğŸ‘‰ Example:
Input:

["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]

Output:[null,null,null,null,false,true,true,true]


âœ… Approach:
Use a TrieNode structure:
-children: dictionary mapping char â†’ TrieNode.
-is_end: marks if a word ends here.
addWord: Insert character by character into the trie. Mark last node as is_end=True.
search: Use DFS to handle two cases:
-If current character is a letter â†’ move to the corresponding child.
-If current character is "." â†’ recursively try all children.
Return True if traversal reaches the end and is_end=True.

class TrieNode:
    def __init__(self):
        self.children = {}   # char â†’ TrieNode
        self.is_end = False

class WordDictionary:

    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word: str) -> None:
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.is_end = True

    def search(self, word: str) -> bool:
        def dfs(node, i):
            # Base case: reached end of word
            if i == len(word):
                return node.is_end

            ch = word[i]
            if ch == ".":
                # Try all possible children
                for child in node.children.values():
                    if dfs(child, i + 1):
                        return True
                return False
            else:
                if ch not in node.children:
                    return False
                return dfs(node.children[ch], i + 1)

        return dfs(self.root, 0)


ğŸ” Dry Run:

Input:

obj = WordDictionary()
obj.addWord("bad")
obj.addWord("dad")
obj.addWord("mad")
obj.search("pad")  â†’ False
obj.search("bad")  â†’ True
obj.search(".ad")  â†’ True
obj.search("b..")  â†’ True

Step by Step:

Insert "bad", "dad", "mad" â†’ trie stores them.
Search "pad" â†’ not found â†’ False.
Search "bad" â†’ exact match â†’ True.
Search ".ad" â†’ . matches b, d, or m. Found "bad" â†’ True.
Search "b.." â†’ b fixed, .. match a + d â†’ "bad" found â†’ True.

ğŸ“Š Time Complexity:
-addWord: O(m), where m = length of word.
-search: Worst case O(26^m) if all chars are ".", but typically O(m) for normal words.

ğŸ§  Space Complexity:
-Worst case: O(N Ã— M) for N words of average length M.
