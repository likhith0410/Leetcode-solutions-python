LeetCode Problem 215: Kth Largest Element in an Array

Difficulty: Medium

🧠 Problem Statement:
Given an integer array nums and an integer k, return the kth largest element in the array.

👉 Note: This is the kth largest in sorted order, not necessarily the kth distinct element.
👉 Try solving it without sorting the entire array.

Example:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Explanation: The sorted array is [1,2,3,4,5,6], and the 2nd largest is 5.

✅ Approach 1: Min-Heap (Heapq)
-Keep a min-heap of size k.
-Push elements into heap → if size > k, pop smallest.
-After processing all numbers, the root of the heap is the kth largest.


class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        min_heap = []
        for num in nums:
            heapq.heappush(min_heap, num)
            if len(min_heap) > k:
                heapq.heappop(min_heap)
        return min_heap[0]


🔁 Dry Run (Heap):
Input: nums = [3,2,1,5,6,4], k = 2
Insert: [3] → [2,3] → pop → [3]
Insert 1 → [1,3] → pop → [3]
Insert 5 → [3,5] (ok)
Insert 6 → [5,6] (after popping smaller)
Insert 4 → [4,6] → pop → [5,6]
✅ Heap root = 5 (2nd largest).

📊 Time Complexity (Heap):
-Insertion/deletion = O(log k) per element.
-Total = O(n log k).

🧠 Space Complexity:
-O(k) for the heap.

✅ Approach 2: Quickselect (Hoare Partition)
Convert problem: kth largest → (n-k)th smallest.
Use quickselect with random pivot:
-Partition array into < pivot and > pivot.
-If (n-k) lies in left side, recurse left.
-If (n-k) lies in right side, recurse right.
-Otherwise, pivot position is the answer.


class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        k = len(nums) - k  # convert to kth smallest index

        def quickselect(l, r):
            pivot = nums[random.randint(l, r)]
            left, right = l, r

            while left <= right:
                while nums[left] < pivot:
                    left += 1
                while nums[right] > pivot:
                    right -= 1
                if left <= right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left, right = left + 1, right - 1

            if k <= right:
                return quickselect(l, right)
            elif k >= left:
                return quickselect(left, r)
            else:
                return nums[k]

        return quickselect(0, len(nums)-1)


🔁 Dry Run (Quickselect):
Input: nums = [3,2,1,5,6,4], k = 2
Target index = 6 - 2 = 4 (4th smallest).
Suppose pivot = 3 → partition → [2,1,3,5,6,4].
Index 4 lies in right side → recurse on [5,6,4].
Pivot = 6 → partition → [5,4,6].
Index 4 now points to 5.
✅ Result = 5.

📊 Time Complexity (Quickselect):
-Average: O(n) (good pivot choices).
-Worst: O(n²) (bad pivots every time).

🧠 Space Complexity:
-O(1) (in-place partition).

✨ Comparison of Approaches:
Heap (O(n log k)) → safer, predictable, best when k is small.
Quickselect (O(n) avg) → faster in practice, but worst-case slower.
