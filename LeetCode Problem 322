LeetCode Problem 322: Coin Change

Difficulty: Medium

🧠 Problem Statement:
You are given an integer array coins representing coin denominations and an integer amount.
Return the minimum number of coins needed to make amount.
If it’s impossible, return -1.
You have infinite supply of each coin.

👉 Key Insights:
This is a classic DP (Unbounded Knapsack) problem.
Define dp[i] = minimum coins needed to make amount i.
Base case: dp[0] = 0.
Transition:
dp[i] = min(dp[i], dp[i - coin] + 1)   for each coin <= i

Answer: dp[amount], or -1 if unreachable.

✅ Approach (Dynamic Programming - Bottom Up):
Initialize DP array with ∞ (meaning impossible initially).
Set dp[0] = 0 → no coins needed for amount 0.
For each amount i from 1 → amount:
-Try every coin:
--If i - coin >= 0, update dp[i] = min(dp[i], dp[i-coin] + 1).
At the end, return dp[amount] (or -1 if still ∞).

📝 Code:
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # Initialize DP array with infinity (unreachable)
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0  # Base case: 0 coins to make 0

        for i in range(1, amount + 1):
            for coin in coins:
                if i - coin >= 0:
                    dp[i] = min(dp[i], dp[i - coin] + 1)

        return dp[amount] if dp[amount] != float('inf') else -1


🔁 Dry Run:
Input: coins = [1,2,5], amount = 11
dp[0] = 0
Build up:
dp[1] = 1 (1 coin of 1)
dp[2] = 1 (1 coin of 2)
dp[3] = 2 (2 + 1)
dp[5] = 1 (one 5)
dp[11] = 3 (5 + 5 + 1)

✅ Final Answer: 3

📊 Time Complexity:
-O(amount × number_of_coins)

🧠 Space Complexity:
-O(amount) for the DP array
