LeetCode Problem 105: Construct Binary Tree from Preorder and Inorder Traversal

Difficulty: Medium

ğŸ§  Problem Statement:
Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.

âœ… Example:
Input:  preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]  
Output: [3,9,20,null,null,15,7]  


âœ… Approach:
We can solve this using recursion and a hashmap:

Observation:
-Preorder always gives the root node first.
-Inorder helps us split the tree into left subtree and right subtree around the root.

Steps:
-Build a hashmap (inorder_map) for quick lookup of index positions in inorder.
-Use a pointer preorder_index to track the current root in preorder.
-Recursive function array_to_tree(left, right) will:
--Stop if left > right.
--Pick root value from preorder.
--Create root node.
--Recursively build left subtree (inorder left side).
--Recursively build right subtree (inorder right side).
-Return the constructed root node.

This ensures O(n) construction using preorder + inorder arrays.

ğŸ’» Code (Python):

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        # Map value â†’ index in inorder for quick lookup
        inorder_map = {val: idx for idx, val in enumerate(inorder)}
        preorder_index = 0  # pointer to track current root in preorder

        def array_to_tree(left, right):
            nonlocal preorder_index
            if left > right:
                return None

            # Pick current root from preorder
            root_val = preorder[preorder_index]
            preorder_index += 1

            root = TreeNode(root_val)

            # Build left & right subtrees using inorder split
            root.left = array_to_tree(left, inorder_map[root_val] - 1)
            root.right = array_to_tree(inorder_map[root_val] + 1, right)

            return root

        return array_to_tree(0, len(inorder) - 1)


ğŸ” Dry Run:
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Root = 3 (from preorder)
In inorder â†’ [9] | 3 | [15,20,7]
Left subtree = [9], Right subtree = [15,20,7]
Next root = 9 â†’ only left child.
Next root = 20 â†’ split inorder [15] | 20 | [7].
Left = 15, Right = 7.
Final Tree:

        3
       / \
      9   20
         /  \
        15   7


âœ… Final Output: [3,9,20,null,null,15,7]

ğŸ“Š Time Complexity:
-O(n): Each node is processed once using hashmap lookups.

ğŸ§  Space Complexity:
-O(n): Hashmap storage + recursion stack.

