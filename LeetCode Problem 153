LeetCode Problem 153: Find Minimum in Rotated Sorted Array

Difficulty: Medium

ðŸ§  Problem Statement:
Suppose an array of length n sorted in ascending order is rotated between 1 and n times.

Example rotations:
[0,1,2,4,5,6,7] â†’ [4,5,6,7,0,1,2] (rotated 4 times)
[0,1,2,4,5,6,7] â†’ [0,1,2,4,5,6,7] (rotated 7 times = same array)

ðŸ‘‰ Given the rotated sorted array nums of unique elements, return the minimum element.
ðŸ‘‰ Must run in O(log n) time.

Example:
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array [1,2,3,4,5] was rotated 3 times.

âœ… Approach:
-We use binary search to find the rotation point (smallest element).
Steps:
Initialize left = 0, right = len(nums) - 1.
While left < right:
-Compute mid = (left + right) // 2.
-If nums[mid] > nums[right], then the minimum is in the right half â†’ move left = mid + 1.
-Else, the minimum is in the left half (including mid) â†’ move right = mid.
At the end, left points to the minimum element.

class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[right]:
                # Minimum is in the right half
                left = mid + 1
            else:
                # Minimum is in the left half (including mid)
                right = mid

        return nums[left]


ðŸ” Dry Run:
Input: nums = [3,4,5,1,2]

Step 1: left = 0, right = 4, mid = 2 â†’ nums[mid] = 5
â†’ 5 > 2, so min is in right half â†’ left = 3.

Step 2: left = 3, right = 4, mid = 3 â†’ nums[mid] = 1
â†’ 1 <= 2, so min is in left half â†’ right = 3.

Now left == right == 3.
âœ… Final Output: nums[3] = 1.

ðŸ“Š Time Complexity:
-O(log n) â†’ Binary search.

ðŸ§  Space Complexity:
-O(1) â†’ Only uses pointers, no extra space.
