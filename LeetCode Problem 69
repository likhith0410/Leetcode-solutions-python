LeetCode Problem 69: Sqrt(x)

Difficulty: Easy

🧠 Problem Statement:
Given a non-negative integer x, return the square root of x, rounded down to the nearest integer.
👉 Constraints:
You cannot use built-in functions like pow(x, 0.5) or x ** 0.5.
Answer must be an integer (rounded down).

Example 1
Input:x = 4
Check:√4 = 2
Output:2

Example 2
Input:x = 8
Check:√8 ≈ 2.828 → round down → 2
Output:2

✅ Approach (Binary Search):
Edge cases: if x = 0 or x = 1, return x.
Use binary search in range [1, x//2] (since √x ≤ x/2 for x > 1).
For each mid:
-If mid² <= x, store mid as possible answer and move right.
-Else, move left.
At the end, ans is the floor of √x.

Code
class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:  # sqrt(0)=0, sqrt(1)=1
            return x

        left, right = 1, x // 2   # search space
        ans = 0

        while left <= right:
            mid = (left + right) // 2
            if mid * mid <= x:
                ans = mid        # valid candidate
                left = mid + 1   # try bigger
            else:
                right = mid - 1  # try smaller

        return ans


🔁 Dry Run:
Input: x = 8
left=1, right=4
mid=2 → 2²=4 ≤ 8 → ans=2 → left=3
mid=3 → 3²=9 > 8 → right=2
stop → return ans=2 ✅

📊 Time Complexity:
-O(log n) → binary search.

🧠 Space Complexity:
-O(1) → constant extra space.

⚡ Key Insight:
We don’t need exact √x, only floor(√x).
Binary search ensures efficiency even for large x.
