LeetCode Problem 162: Find Peak Element

Difficulty: Medium

🧠 Problem Statement:
A peak element is an element that is strictly greater than its neighbors.
You are given an array nums.
Return the index of any peak.
Assume nums[-1] = nums[n] = -∞, so edges can also be peaks.
Must solve in O(log n) time.

Example 1:
Input:nums = [1,2,1,3,5,6,4]
Output:5

Explanation:
-Index 1 → value 2 is a peak (since 2 > 1 on both sides).
-Index 5 → value 6 is a peak (since 6 > 5 and 6 > 4).
Either index 1 or 5 is valid.

✅ Approach: (Binary Search)
-We use binary search instead of linear scan because:
-If nums[mid] > nums[mid+1], then the peak lies on the left side (including mid).
-Else, if nums[mid] < nums[mid+1], the peak lies on the right side.
-Keep shrinking the search space until left == right.
-This works because there must always be a peak due to the -∞ boundary condition.

📝 Code:
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[mid + 1]:
                # Peak lies on the left side (including mid)
                right = mid
            else:
                # Peak lies on the right side
                left = mid + 1

        return left

🔁 Dry Run:

Input: nums = [1,2,1,3,5,6,4]

left=0, right=6 → mid=3 → nums[3]=3, nums[4]=5
→ 3 < 5 → peak on right → left=4.
left=4, right=6 → mid=5 → nums[5]=6, nums[6]=4
→ 6 > 4 → peak on left → right=5.
left=4, right=5 → mid=4 → nums[4]=5, nums[5]=6
→ 5 < 6 → peak on right → left=5.

Now left == right == 5 → return 5. ✅

📊 Time Complexity:
-O(log n) → binary search halves the array each step.

🧠 Space Complexity:
-O(1) → constant extra space.
