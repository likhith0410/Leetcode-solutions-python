LeetCode Problem 148: Sort List

Difficulty: Medium

ðŸ§  Problem Statement:
Given the head of a linked list, return the list after sorting it in ascending order.

Example:
Input:head = [4,2,1,3]
Output:[1,2,3,4]

âœ… Approach: Merge Sort on Linked List

ðŸ‘‰ Why Merge Sort?
Array sorting (like quicksort) needs random access, which linked lists donâ€™t support efficiently.
Merge sort works well on linked lists because splitting and merging can be done in O(1) extra space.
Steps:
-Base case:
--If list is empty or has one node â†’ already sorted.
-Split the list:
--Use slow & fast pointers to find the middle node.
--Break list into two halves.
-Recursively sort:
--Sort left and right halves.
-Merge sorted halves:
--Use helper merge function to merge two sorted lists.

ðŸ“ Code
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Base case: empty or single node
        if not head or not head.next:
            return head

        # 1. Split list into two halves
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        mid = slow.next
        slow.next = None   # cut the list

        # 2. Recursively sort both halves
        left = self.sortList(head)
        right = self.sortList(mid)

        # 3. Merge sorted halves
        return self.merge(left, right)

    def merge(self, l1, l2):
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next


ðŸ” Dry Run:
Input: head = [4,2,1,3]
Split into [4,2] and [1,3].
Sort [4,2] â†’ becomes [2,4].
Sort [1,3] â†’ becomes [1,3].
Merge [2,4] and [1,3]:
Compare 2 vs 1 â†’ take 1.
Compare 2 vs 3 â†’ take 2.
Compare 4 vs 3 â†’ take 3.
Append remaining 4.

Final: [1,2,3,4] âœ…

ðŸ“Š Time Complexity:
-Splitting = O(log n) levels.
-Merging = O(n) work per level.
-Total = O(n log n).

ðŸ§  Space Complexity:
-Merge uses no extra array (just pointers).
-Recursion stack depth = O(log n).
