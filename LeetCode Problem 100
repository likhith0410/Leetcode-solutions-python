LeetCode Problem 100: Same Tree

Difficulty: Easy

ğŸ§  Problem Statement:
Given the roots of two binary trees p and q, write a function to check if they are the same or not.

ğŸ‘‰ Two binary trees are considered the same if:
-They are structurally identical.
-Their corresponding nodes have the same values.

Input: p = [1,2,3], q = [1,2,3]
Output: true

âœ… Approach:
Use recursion to compare the two trees node by node:
-Base Case 1: If both nodes are None, they are equal â†’ return True.
-Base Case 2: If one is None and the other is not, they differ â†’ return False.
-Value Check: If p.val != q.val, return False.
-Recursive Step: Check p.left == q.left and p.right == q.right.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # Case 1: Both are None â†’ same
        if not p and not q:
            return True
        
        # Case 2: One is None â†’ not same
        if not p or not q:
            return False
        
        # Case 3: Values differ â†’ not same
        if p.val != q.val:
            return False
        
        # Recursively check left & right subtrees
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

ğŸ” Dry Run:
Input: p = [1,2,3], q = [1,2,3]
Compare root (1 vs 1) â†’ same.
Compare left (2 vs 2) â†’ same.
Compare right (3 vs 3) â†’ same.
Both trees fully matched.
âœ… Final Output: True

ğŸ“Š Time Complexity:
O(n): Visit each node once (where n = number of nodes).

ğŸ§  Space Complexity:
O(h): Recursion stack (h = tree height).
-Worst case skewed tree â†’ O(n).
-Best case balanced tree â†’ O(log n).
