LeetCode Problem 295: Find Median from Data Stream

Difficulty: Hard

ğŸ§  Problem Statement:
The median is the middle value in an ordered integer list.
If the list has odd size â†’ median = middle value.
If the list has even size â†’ median = average of two middle values.
You need to design a data structure MedianFinder with:
MedianFinder() â†’ Initializes the object.
addNum(int num) â†’ Adds an integer into the data stream.
findMedian() â†’ Returns the median of all numbers so far.

Example 1:

Input:
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]

Output:
[null, null, null, 1.5, null, 2.0]

Explanation:
Add 1 â†’ arr = [1]
Add 2 â†’ arr = [1,2] â†’ median = (1+2)/2 = 1.5
Add 3 â†’ arr = [1,2,3] â†’ median = 2.0

âœ… Approach:
We use two heaps to efficiently track the median:
Max Heap (left) â†’ stores the smaller half of numbers (Pythonâ€™s heapq is min-heap, so store negatives).
Min Heap (right) â†’ stores the larger half of numbers.
Always maintain:
-Either both heaps have the same size, OR
-left has exactly 1 more element than right.
Median rules:
-If odd â†’ top of left.
-If even â†’ average of tops of left and right.

class MedianFinder:

    def __init__(self):
        # max heap (store negatives for Python's minheap)
        self.left = []
        # min heap
        self.right = []

    def addNum(self, num: int) -> None:
        # Step 1: add to max heap
        heapq.heappush(self.left, -num)

        # Step 2: balance -> ensure every num in left <= every num in right
        if self.left and self.right and (-self.left[0] > self.right[0]):
            val = -heapq.heappop(self.left)
            heapq.heappush(self.right, val)

        # Step 3: keep sizes balanced (left can only be bigger by 1)
        if len(self.left) > len(self.right) + 1:
            val = -heapq.heappop(self.left)
            heapq.heappush(self.right, val)
        elif len(self.right) > len(self.left):
            val = heapq.heappop(self.right)
            heapq.heappush(self.left, -val)

    def findMedian(self) -> float:
        # odd size -> top of left
        if len(self.left) > len(self.right):
            return -self.left[0]
        # even size -> average of both tops
        return (-self.left[0] + self.right[0]) / 2

        

# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()

ğŸ” Dry Run:
Input: addNum(1), addNum(2), findMedian(), addNum(3), findMedian()
Add 1 â†’ left = [1], right = [] â†’ median = 1
Add 2 â†’ left = [1], right = [2] â†’ median = (1+2)/2 = 1.5
Add 3 â†’ left = [2,1], right = [3] â†’ median = 2

âœ… Output = [null, null, null, 1.5, null, 2.0]

ğŸ“Š Time Complexity:
-addNum â†’ O(log n) (heap push/pop)
-findMedian â†’ O(1)

ğŸ§  Space Complexity:
-Heaps store all numbers â†’ O(n)
