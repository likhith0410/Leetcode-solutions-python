LeetCode Problem 146: LRU Cache

Difficulty: Medium

ğŸ§  Problem Statement:
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the class LRUCache with the following methods:

LRUCache(int capacity): Initialize the cache with a positive capacity.

int get(int key): Return the value of the key if it exists, otherwise return -1.

void put(int key, int value): Update the value of the key if it exists. Otherwise, add the key-value pair to the cache.

If the number of keys exceeds the capacity, evict the least recently used (LRU) key.

ğŸ‘‰ Both get and put must run in O(1) average time complexity.

âœ… Example:

Input:
["LRUCache","put","put","get","put","get","put","get","get","get"]
[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]

Output:
[None,None,None,1,None,-1,None,-1,3,4]


Explanation:

Cache capacity = 2
Put (1,1), Put (2,2) â†’ Cache = {1=1, 2=2}
Get (1) â†’ returns 1, Cache = {2=2, 1=1} (1 is most recently used)
Put (3,3) â†’ evicts key 2, Cache = {1=1, 3=3}
Get (2) â†’ returns -1
Put (4,4) â†’ evicts key 1, Cache = {3=3, 4=4}
Get (1) â†’ returns -1
Get (3) â†’ returns 3
Get (4) â†’ returns 4

âœ… Approach:
-We need O(1) lookups and O(1) updates:
-Use a hashmap (dict) to store key â†’ node mappings for O(1) access.
-Use a doubly linked list to maintain usage order:
-Most recently used â†’ near the head.
-Least recently used â†’ near the tail.

Operations:
-get(key): If exists â†’ move node to head (most recently used). Else return -1.
-put(key, value):
-If key exists â†’ update value and move to head.
-If not exists â†’ insert node at head.
-If over capacity â†’ remove node at tail (least recently used).

ğŸ’» Code (Python):

class Node:
    def __init__(self, key: int, value: int):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> Node

        # Dummy head and tail to avoid edge checks
        self.head = Node(0, 0)  
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    # Remove node from linked list
    def _remove(self, node):
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node

    # Add node right after head (most recently used position)
    def _add_to_head(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    # Move an existing node to the head
    def _move_to_head(self, node):
        self._remove(node)
        self._add_to_head(node)

    # Remove the least recently used node (tail.prev)
    def _pop_tail(self):
        lru_node = self.tail.prev
        self._remove(lru_node)
        return lru_node

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._move_to_head(node)  # mark as most recently used
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            node.value = value  # update value
            self._move_to_head(node)
        else:
            new_node = Node(key, value)
            self.cache[key] = new_node
            self._add_to_head(new_node)

            if len(self.cache) > self.capacity:
                tail_node = self._pop_tail()
                del self.cache[tail_node.key]


ğŸ” Dry Run:
Capacity = 2, Operations = put(1,1), put(2,2), get(1), put(3,3), get(2)

Start: {}
Put(1,1): {1=1}
Put(2,2): {1=1, 2=2}
Get(1): returns 1 â†’ {2=2, 1=1} (1 is MRU)
Put(3,3): evict 2 â†’ {1=1, 3=3}
Get(2): returns -1

âœ… Final state: {1=1, 3=3}

ğŸ“Š Time Complexity:
get: O(1)
put: O(1)

ğŸ§  Space Complexity:
O(capacity): Stores at most capacity nodes in hashmap and linked list.
