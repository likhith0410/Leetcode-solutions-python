LeetCode Problem 210: Course Schedule II

Difficulty: Medium

ğŸ§  Problem Statement:
You are given numCourses courses labeled from 0 to numCourses - 1 and a list of prerequisites, where prerequisites[i] = [a, b] means:
â¡ To take course a, you must first complete course b.
Return the order of courses you should take to finish all courses.
If multiple valid orders exist â†’ return any.
If it is impossible to complete all courses (due to cycles), return an empty list.

âœ… Example:
Input:numCourses = 2, prerequisites = [[1,0]]
Output:[0,1]

Explanation:
To take course 1, you must first finish 0.
So the valid order is [0,1].

âœ… Approach (Topological Sort using BFS - Kahnâ€™s Algorithm):
Observation:
-This is a Directed Graph problem.
-Each course is a node, and prerequisites form directed edges.
-We need to find a topological ordering.
-If a cycle exists â†’ no valid order.
Steps:
-Build a graph (adjacency list) and an indegree array (tracks prerequisites count for each course).
-Initialize a queue with all courses having indegree 0 (no prerequisites).
-Perform BFS:
--Pop a course from the queue â†’ add it to order.
--Reduce indegree of its neighbors (dependent courses).
--If a neighborâ€™s indegree becomes 0, push it into the queue.
-If all courses are processed â†’ return order.
Otherwise (cycle detected) â†’ return [].

ğŸ’» Code (Python):
from collections import deque
from typing import List

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # Step 1: Build graph + indegree count
        graph = {i: [] for i in range(numCourses)}
        indegree = [0] * numCourses

        for a, b in prerequisites:
            graph[b].append(a)   # b -> a (to take a, must do b first)
            indegree[a] += 1

        # Step 2: Queue with nodes having indegree 0 (no prerequisites)
        queue = deque([i for i in range(numCourses) if indegree[i] == 0])
        order = []

        # Step 3: Process queue
        while queue:
            course = queue.popleft()
            order.append(course)

            for neigh in graph[course]:
                indegree[neigh] -= 1
                if indegree[neigh] == 0:
                    queue.append(neigh)

        # Step 4: Check if all courses are processed
        return order if len(order) == numCourses else []

ğŸ” Dry Run:

Input:numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]

Graph:
0 â†’ [1,2]
1 â†’ [3]
2 â†’ [3]
3 â†’ []

Indegree = [0,1,1,2]
Start with queue = [0]

Process:
Pop 0, order = [0] â†’ update indegree â†’ [0,0,0,2], push 1,2.
Pop 1, order = [0,1] â†’ indegree â†’ [0,0,0,1].
Pop 2, order = [0,1,2] â†’ indegree â†’ [0,0,0,0], push 3.
Pop 3, order = [0,1,2,3].
âœ… Final Output: [0,1,2,3]

ğŸ“Š Time Complexity:
O(V + E) â†’ V = courses, E = prerequisites.
Building graph + BFS traversal.

ğŸ§  Space Complexity:
O(V + E) â†’ Graph + indegree array + queue.
