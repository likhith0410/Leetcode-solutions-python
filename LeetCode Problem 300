LeetCode Problem 300: Longest Increasing Subsequence

Difficulty: Medium

ðŸ§  Problem Statement:
Given an integer array nums, return the length of the longest strictly increasing subsequence (LIS).

ðŸ‘‰ A subsequence means we can delete some elements without changing the order of the remaining ones.

Example:
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The LIS is [2,3,7,101].

âœ… Approach (Dynamic Programming):
We use DP where:
-dp[i] = length of LIS ending at index i.
-Initialize dp with 1 because the minimum LIS ending at any index is the element itself.
-For each element nums[i], check all previous elements nums[j] (j < i):
--If nums[j] < nums[i], it means we can extend the LIS ending at j.
--Update: dp[i] = max(dp[i], dp[j] + 1)
Finally, the answer is max(dp) because LIS can end at any index.

ðŸ“ Code:

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        # dp[i] = length of LIS ending at index i
        dp = [1] * n  

        for i in range(n):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)


ðŸ” Dry Run:
Input: nums = [10,9,2,5,3,7,101,18]
Start with dp = [1,1,1,1,1,1,1,1].
Compare step by step:
At i=3 (nums[3]=5), LIS = [2,5] â†’ dp[3] = 2.
At i=5 (nums[5]=7), LIS = [2,3,7] â†’ dp[5] = 3.
At i=6 (nums[6]=101), LIS = [2,3,7,101] â†’ dp[6] = 4.
Final dp = [1,1,1,2,2,3,4,4].

âœ… Answer = max(dp) = 4.

ðŸ“Š Time Complexity:
-O(n^2) â†’ Two loops (for each pair (i, j)).

ðŸ§  Space Complexity:
-O(n) â†’ DP array to store LIS lengths.
